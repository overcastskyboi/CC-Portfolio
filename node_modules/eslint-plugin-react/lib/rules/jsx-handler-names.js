/**
 * @fileoverview Enforce event handler naming conventions in JSX
 * @author Jake Marsh
 */

'use strict';

<<<<<<< HEAD
const docsUrl = require('../util/docsUrl');
=======
const minimatch = require('minimatch');
const docsUrl = require('../util/docsUrl');
const getText = require('../util/eslint').getText;
const report = require('../util/report');
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

<<<<<<< HEAD
=======
const messages = {
  badHandlerName: 'Handler function for {{propKey}} prop key must be a camelCase name beginning with \'{{handlerPrefix}}\' only',
  badPropKey: 'Prop key for {{propValue}} must begin with \'{{handlerPropPrefix}}\'',
};

function isPrefixDisabled(prefix) {
  return prefix === false;
}

function isInlineHandler(node) {
  return node.value.expression.type === 'ArrowFunctionExpression';
}

/** @type {import('eslint').Rule.RuleModule} */
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
module.exports = {
  meta: {
    docs: {
      description: 'Enforce event handler naming conventions in JSX',
      category: 'Stylistic Issues',
      recommended: false,
<<<<<<< HEAD
      url: docsUrl('jsx-handler-names')
    },

=======
      url: docsUrl('jsx-handler-names'),
    },

    messages,

>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    schema: [{
      anyOf: [
        {
          type: 'object',
          properties: {
<<<<<<< HEAD
            eventHandlerPrefix: {type: 'string'},
            eventHandlerPropPrefix: {type: 'string'},
            checkLocalVariables: {type: 'boolean'},
            checkInlineFunction: {type: 'boolean'}
          },
          additionalProperties: false
        }, {
          type: 'object',
          properties: {
            eventHandlerPrefix: {type: 'string'},
            eventHandlerPropPrefix: {
              type: 'boolean',
              enum: [false]
            },
            checkLocalVariables: {type: 'boolean'},
            checkInlineFunction: {type: 'boolean'}
          },
          additionalProperties: false
=======
            eventHandlerPrefix: { type: 'string' },
            eventHandlerPropPrefix: { type: 'string' },
            checkLocalVariables: { type: 'boolean' },
            checkInlineFunction: { type: 'boolean' },
            ignoreComponentNames: {
              type: 'array',
              uniqueItems: true,
              items: { type: 'string' },
            },
          },
          additionalProperties: false,
        }, {
          type: 'object',
          properties: {
            eventHandlerPrefix: { type: 'string' },
            eventHandlerPropPrefix: {
              type: 'boolean',
              enum: [false],
            },
            checkLocalVariables: { type: 'boolean' },
            checkInlineFunction: { type: 'boolean' },
            ignoreComponentNames: {
              type: 'array',
              uniqueItems: true,
              items: { type: 'string' },
            },
          },
          additionalProperties: false,
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        }, {
          type: 'object',
          properties: {
            eventHandlerPrefix: {
              type: 'boolean',
<<<<<<< HEAD
              enum: [false]
            },
            eventHandlerPropPrefix: {type: 'string'},
            checkLocalVariables: {type: 'boolean'},
            checkInlineFunction: {type: 'boolean'}
          },
          additionalProperties: false
        }, {
          type: 'object',
          properties: {
            checkLocalVariables: {type: 'boolean'}
          },
          additionalProperties: false
        }, {
          type: 'object',
          properties: {
            checkInlineFunction: {type: 'boolean'}
          },
          additionalProperties: false
        }
      ]
    }]
  },

  create(context) {
    function isPrefixDisabled(prefix) {
      return prefix === false;
    }

    function isInlineHandler(node) {
      return node.value.expression.type === 'ArrowFunctionExpression';
    }

=======
              enum: [false],
            },
            eventHandlerPropPrefix: { type: 'string' },
            checkLocalVariables: { type: 'boolean' },
            checkInlineFunction: { type: 'boolean' },
            ignoreComponentNames: {
              type: 'array',
              uniqueItems: true,
              items: { type: 'string' },
            },
          },
          additionalProperties: false,
        }, {
          type: 'object',
          properties: {
            checkLocalVariables: { type: 'boolean' },
          },
          additionalProperties: false,
        }, {
          type: 'object',
          properties: {
            checkInlineFunction: { type: 'boolean' },
          },
          additionalProperties: false,
        },
        {
          type: 'object',
          properties: {
            ignoreComponentNames: {
              type: 'array',
              uniqueItems: true,
              items: { type: 'string' },
            },
          },
        },
      ],
    }],
  },

  create(context) {
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
    const configuration = context.options[0] || {};

    const eventHandlerPrefix = isPrefixDisabled(configuration.eventHandlerPrefix)
      ? null
      : configuration.eventHandlerPrefix || 'handle';
    const eventHandlerPropPrefix = isPrefixDisabled(configuration.eventHandlerPropPrefix)
      ? null
      : configuration.eventHandlerPropPrefix || 'on';

    const EVENT_HANDLER_REGEX = !eventHandlerPrefix
      ? null
      : new RegExp(`^((props\\.${eventHandlerPropPrefix || ''})|((.*\\.)?${eventHandlerPrefix}))[0-9]*[A-Z].*$`);
    const PROP_EVENT_HANDLER_REGEX = !eventHandlerPropPrefix
      ? null
      : new RegExp(`^(${eventHandlerPropPrefix}[A-Z].*|ref)$`);

    const checkLocal = !!configuration.checkLocalVariables;

    const checkInlineFunction = !!configuration.checkInlineFunction;

<<<<<<< HEAD
    return {
      JSXAttribute(node) {
=======
    const ignoreComponentNames = configuration.ignoreComponentNames || [];

    return {
      JSXAttribute(node) {
        const componentName = node.parent.name.name;

        const isComponentNameIgnored = ignoreComponentNames.some((ignoredComponentNamePattern) => minimatch(
          componentName,
          ignoredComponentNamePattern
        ));

>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        if (
          !node.value
          || !node.value.expression
          || (!checkInlineFunction && isInlineHandler(node))
          || (
            !checkLocal
            && (isInlineHandler(node)
              ? !node.value.expression.body.callee || !node.value.expression.body.callee.object
              : !node.value.expression.object
            )
          )
<<<<<<< HEAD
=======
          || isComponentNameIgnored
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
        ) {
          return;
        }

        const propKey = typeof node.name === 'object' ? node.name.name : node.name;
        const expression = node.value.expression;
<<<<<<< HEAD
        const propValue = context.getSourceCode()
          .getText(checkInlineFunction && isInlineHandler(node) ? expression.body.callee : expression)
          .replace(/\s*/g, '')
          .replace(/^this\.|.*::/, '');
=======
        const propValue = getText(
          context,
          checkInlineFunction && isInlineHandler(node) ? expression.body.callee : expression
        ).replace(/\s*/g, '').replace(/^this\.|.*::/, '');
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)

        if (propKey === 'ref') {
          return;
        }

        const propIsEventHandler = PROP_EVENT_HANDLER_REGEX && PROP_EVENT_HANDLER_REGEX.test(propKey);
        const propFnIsNamedCorrectly = EVENT_HANDLER_REGEX && EVENT_HANDLER_REGEX.test(propValue);

        if (
          propIsEventHandler
          && propFnIsNamedCorrectly !== null
          && !propFnIsNamedCorrectly
        ) {
<<<<<<< HEAD
          context.report({
            node,
            message: `Handler function for ${propKey} prop key must be a camelCase name beginning with '${eventHandlerPrefix}' only`
=======
          report(context, messages.badHandlerName, 'badHandlerName', {
            node,
            data: {
              propKey,
              handlerPrefix: eventHandlerPrefix,
            },
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
          });
        } else if (
          propFnIsNamedCorrectly
          && propIsEventHandler !== null
          && !propIsEventHandler
        ) {
<<<<<<< HEAD
          context.report({
            node,
            message: `Prop key for ${propValue} must begin with '${eventHandlerPropPrefix}'`
          });
        }
      }
    };
  }
=======
          report(context, messages.badPropKey, 'badPropKey', {
            node,
            data: {
              propValue,
              handlerPropPrefix: eventHandlerPropPrefix,
            },
          });
        }
      },
    };
  },
>>>>>>> 100f0e1 (feat: implement routing, watchlist overhaul, and decommission console)
};
